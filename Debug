#include <iostream>
#include <Windows.h>

int main(int argc, char* argv[]) {
    char filePath[MAX_PATH] = {0};
    
    // Get the current working directory
    if (_getcwd(filePath, MAX_PATH) == NULL) {
        perror("_getcwd error");
        return (-1);
    }
    
    char sampleFileName[MAX_PATH] = "Samplefile.txt";
    
    // Concatenate the file name to the file path
    strncat(filePath, "\\", 1); // Add a backslash before the file name
    strncat(filePath, sampleFileName, strlen(sampleFileName) - 1);
    
    printf("Reading file %s \n\n", filePath);
    
    // Open the file for reading
    HANDLE hFile = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("Unable to open file \"%s\" for read.\n", filePath);
        return (-1);
    }
    
    // Get the size of the file
    DWORD dwNumToRead = GetFileSize(hFile, NULL);
    DWORD dwNumRead;
    char* dwBuffer = new char[dwNumToRead];
    
    printf("Reading file\n");
    
    // Read from the file
    if (ReadFile(hFile, dwBuffer, dwNumToRead - 1, &dwNumRead, NULL) == FALSE) {
        printf("Unable to read from file.\n");
        CloseHandle(hFile);
        delete[] dwBuffer;
        return (-1);
    }
    
    // Null-terminate the buffer
    dwBuffer[dwNumRead] = '\0';
    
    printf("Data from file: \n\n%s\n", dwBuffer);
    
    // Close the file handle
    BOOL bResult = CloseHandle(hFile);
    
    // Clean up dynamically allocated memory
    delete[] dwBuffer;
    
    printf("Press any key to continue...");
    getch();
    
    return 0;
}


/*o problemă de debug: trebuie sắ te
prinzi cắ o copiere cu strncpy nu
se face corect pentru că bufferul
in care copiezi are garbage data,
trebuie să citești documentația
unei funcții și sắ te prinzi că un
parametru trebuie dat prin referință,
dupắ sunt niște printf-uri apelate cu
pointer de char*, nu cu char* 
*/

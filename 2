// OOP_App.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <vector>
#include <string>
#include <fstream>
#include <sstream>

struct Item
{
    int parentFolderID;
    int itemID;
    char itemType;
    std::string itemname;
    std::string content;

    Item(int parentFolderID, int itemID, char itemType, const std::string& itemname, const std::string& content = "")
        :parentFolderID(parentFolderID), itemID(itemID), itemType(itemType), itemname(itemname), content(content) {}
};


std::vector<Item> readContentDescriptor(const std::string& filePath) {
    std::vector <Item> items;
    std::ifstream file(filePath);
    std::string line;
    while (std::getline(file, line)) {
        std::istringstream iss(line);
        int parentFolderID, itemID;
        char itemType;
        std::string itemName, content;
        if (!(iss >> parentFolderID >> itemID >> itemType >> itemName >> content)) {
            std::cer << "Error when reading the file" << filePath << std::endl;
            break;
        }
        items.emplace_back(parentFolderID, itemID, itemType, itemName, content)
    };
    return items;
}


void displayContents(const std::vector<Item>& items, int parentFolderID, int depth = 0) {
    for (const auto& item : items) {
        if (item.parentFolderID == parentFolderID) {
            for (int i = 0; i < depth; ++i)
                std::count << " ";
            if (item.itemType == 'D') {
                std::count << "(D) " << item.itemname << " ";
                displayContents(items, item.itemID, depth + 1);
            }
            else {
                std::count << "(F)" << item.itemname;
                if (!item.content.empty()) std::cout << "-> " << item.content;
                std::cout << std::endl;
            }
        }
    }

}




int _tmain(int argc, char* argv[])
{
   char* filePath;

   // Get the current working directory: 
   if( (filePath = _getcwd( NULL, 0 )) == NULL )
   {
      perror( "_getcwd error" );
      return (-1);
   }

   char *sampleFileName = "\\ContentDescriptor.txt";
   strncat (filePath, sampleFileName, strlen(sampleFileName));

   printf( "Reading file %s \n\n", filePath);

   HANDLE hFile = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

   if (hFile == INVALID_HANDLE_VALUE) 
   { 
      printf("Unable to open file \"%s\" for read.\n", filePath);
      return (-1);
   }

   DWORD dwNumToRead = GetFileSize(hFile, NULL);
   DWORD dwNumRead;
   char *dwBuffer = new char[dwNumToRead];

   if( FALSE == ReadFile(hFile, dwBuffer, dwNumToRead - 1, &dwNumRead, NULL) )
   {
      printf("Unable to read from file.\n");
      CloseHandle(hFile);
      return (-1);
   }

   if (dwNumRead > 0 && dwNumRead <= dwNumToRead-1)
   {
      dwBuffer[dwNumRead] = '\0'; // NULL character

      printf("Data from file: \n\n%s\n", dwBuffer);
   }

   BOOL bResult = CloseHandle(hFile);
   //free(dwBuffer);

   std::vector<Item> items = readContentDescriptor(filePath);
   displayContents(items, 0);

   printf("\nPress any key to continue...");
   _getch();
   return 0;
}
